// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model for authentication
model User {
  id                 String             @id @default(uuid())
  email              String             @unique
  passwordHash       String
  role               UserRole
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  coachProfile       CoachProfile?
  athleteProfile     AthleteProfile?
  benchmarks         AthleteBenchmark[]
  coachWeeklyPlans   WeeklyPlan[]       @relation("CoachWeeklyPlans")
  athleteWeeklyPlans WeeklyPlan[]       @relation("AthleteWeeklyPlans")
  workoutLogs        WorkoutLog[]

  @@map("users")
}

enum UserRole {
  COACH
  ATHLETE
}

// Coach-specific profile
model CoachProfile {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  athletes        CoachAthlete[]
  sentInvitations Invitation[]
  auditLogs       AuditLog[]

  @@map("coach_profiles")
}

// Athlete-specific profile
model AthleteProfile {
  id        String   @id @default(uuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  coaches           CoachAthlete[]
  deviceConnections DeviceConnection[]

  @@map("athlete_profiles")
}

// Coach-Athlete relationship (roster)
model CoachAthlete {
  id               String         @id @default(uuid())
  coachProfileId   String
  athleteProfileId String
  coachProfile     CoachProfile   @relation(fields: [coachProfileId], references: [id], onDelete: Cascade)
  athleteProfile   AthleteProfile @relation(fields: [athleteProfileId], references: [id], onDelete: Cascade)
  linkedAt         DateTime       @default(now())

  @@unique([coachProfileId, athleteProfileId])
  @@map("coach_athletes")
}

// Invitation model
model Invitation {
  id             String           @id @default(uuid())
  coachProfileId String
  coachProfile   CoachProfile     @relation(fields: [coachProfileId], references: [id], onDelete: Cascade)
  invitedEmail   String
  tokenHash      String           @unique
  status         InvitationStatus @default(PENDING)
  expiresAt      DateTime
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  @@index([coachProfileId, invitedEmail, status])
  @@map("invitations")
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

// Audit log for tracking invitation events
model AuditLog {
  id             String       @id @default(uuid())
  coachProfileId String
  coachProfile   CoachProfile @relation(fields: [coachProfileId], references: [id], onDelete: Cascade)
  athleteUserId  String?
  invitationId   String?
  action         String
  timestamp      DateTime     @default(now())
  metadata       Json?

  @@map("audit_logs")
}

// Exercise catalog
model Exercise {
  id             String       @id @default(uuid())
  name           String
  type           ExerciseType
  modality       Modality?
  description    String?
  videoUrl       String?
  primaryMuscles Json?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@map("exercises")
}

enum ExerciseType {
  STRENGTH
  ENDURANCE
}

enum Modality {
  GYM
  BIKE
  RUN
  SWIM
}

// Athlete benchmark metrics
model AthleteBenchmark {
  id            String       @id @default(uuid())
  athleteUserId String
  athleteUser   User         @relation(fields: [athleteUserId], references: [id], onDelete: Cascade)
  key           BenchmarkKey
  context       String?
  value         Float
  unit          String
  measuredAt    DateTime
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@index([athleteUserId, key])
  @@map("athlete_benchmarks")
}

enum BenchmarkKey {
  FTP
  HR_MAX
  HR_REST
  ONE_RM
}

enum SessionType {
  STRENGTH
  ENDURANCE
}

enum SessionStatus {
  PLANNED
  COMPLETED
  MISSED
  MODIFIED
}

model WeeklyPlan {
  id            String            @id @default(uuid())
  coachId       String
  coach         User              @relation("CoachWeeklyPlans", fields: [coachId], references: [id], onDelete: Cascade)
  athleteUserId String
  athlete       User              @relation("AthleteWeeklyPlans", fields: [athleteUserId], references: [id], onDelete: Cascade)
  weekStart     DateTime          @db.Date // Normalized to Monday (YYYY-MM-DD)
  notes         String?
  sessions      TrainingSession[]
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  @@unique([athleteUserId, weekStart])
  @@index([coachId])
  @@index([athleteUserId, weekStart])
  @@map("weekly_plans")
}

model TrainingSession {
  id               String        @id @default(uuid())
  weeklyPlanId     String
  weeklyPlan       WeeklyPlan    @relation(fields: [weeklyPlanId], references: [id], onDelete: Cascade)
  date             DateTime      @db.Date // Session date (YYYY-MM-DD)
  type             SessionType
  title            String
  prescription     Json // Type-specific JSON schema
  status           SessionStatus @default(PLANNED)
  completedAt      DateTime?
  workoutLog       WorkoutLog?
  // Export status fields (for ENDURANCE sessions)
  exportStatus     ExportStatus? @default(NOT_CONNECTED)
  exportProvider   DeviceProvider?
  exportedAt       DateTime?
  externalWorkoutId String? // Provider's workout ID
  lastExportError  String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([weeklyPlanId])
  @@index([date])
  @@index([exportStatus]) // Index for querying pending/not_connected sessions
  @@map("training_sessions")
}

model WorkoutLog {
  id            String          @id @default(uuid())
  sessionId     String          @unique
  session       TrainingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  athleteUserId String
  athleteUser   User            @relation(fields: [athleteUserId], references: [id], onDelete: Cascade)
  type          SessionType
  summary       Json
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([athleteUserId])
  @@map("workout_logs")
}

// Device OAuth connection for athletes (Garmin/Wahoo)
model DeviceConnection {
  id               String           @id @default(uuid())
  athleteProfileId String
  athleteProfile   AthleteProfile   @relation(fields: [athleteProfileId], references: [id], onDelete: Cascade)
  provider         DeviceProvider
  accessToken      String // Encrypted at application level
  refreshToken     String // Encrypted at application level
  expiresAt        DateTime // Access token expiration
  status           ConnectionStatus @default(CONNECTED)
  connectedAt      DateTime         @default(now())
  isPrimary        Boolean          @default(false)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  @@unique([athleteProfileId, provider])
  @@index([athleteProfileId])
  @@map("device_connections")
}

enum DeviceProvider {
  GARMIN
  WAHOO
}

enum ConnectionStatus {
  CONNECTED
  EXPIRED
  REVOKED
  ERROR
}

enum ExportStatus {
  NOT_CONNECTED
  PENDING
  SENT
  FAILED
}
